{
  "publisher": "dkattan",
  "name": "copilot-breakpoint-debugger",
  "displayName": "Copilot Breakpoint Debugger",
  "version": "0.0.41",
  "_versionComment": "Version is auto-generated by the CI auto-release workflow. Manual edits are overwritten.",
  "description": "Use GitHub Copilot to automate starting, inspecting and resuming VS Code debug sessions with conditional breakpoints, exact numeric hit counts (hitCount), logpoints, and capture actions that interpolate variables inside log messages.",
  "license": "MIT",
  "homepage": "https://github.com/dkattan/Copilot-Breakpoint-Debugger#readme",
  "repository": {
    "type": "git",
    "url": "https://github.com/dkattan/Copilot-Breakpoint-Debugger"
  },
  "bugs": {
    "url": "https://github.com/dkattan/Copilot-Breakpoint-Debugger/issues"
  },
  "keywords": [
    "copilot",
    "debug",
    "breakpoint",
    "variables",
    "stack",
    "resume",
    "ai"
  ],
  "categories": [
    "Debuggers",
    "Other"
  ],
  "main": "./dist/extension.js",
  "icon": "images/icon.png",
  "engines": {
    "vscode": "^1.102.0"
  },
  "activationEvents": [
    "onLanguageModelTools",
    "onStartupFinished"
  ],
  "contributes": {
    "commands": [
      {
        "command": "copilotBreakpointDebugger.startAndWaitManual",
        "title": "Copilot Breakpoint Debugger: Manual Start & Wait",
        "category": "Copilot Breakpoint Debugger"
      },
      {
        "command": "copilotBreakpointDebugger.insertSampleStartDebuggerPayload",
        "title": "Copilot Breakpoint Debugger: Insert Sample Start Payload",
        "category": "Copilot Breakpoint Debugger"
      }
    ],
    "configuration": {
      "title": "Copilot Breakpoint Debugger",
      "properties": {
        "copilot-debugger.defaultLaunchConfiguration": {
          "type": "string",
          "default": "",
          "description": "Name of the default launch configuration to use when starting the debugger"
        },
        "copilot-debugger.entryTimeoutSeconds": {
          "type": "integer",
          "default": 60,
          "description": "Timeout in seconds waiting for initial entry stop after launching (before first user breakpoint). Supports long startup/build times; must be > 0."
        },
        "copilot-debugger.captureMaxVariables": {
          "type": "integer",
          "default": 40,
          "description": "Maximum number of variables auto-captured when a breakpoint onHit=captureAndContinue omits variableFilter (capture-all mode)."
        },
        "copilot-debugger.serverReadyEnabled": {
          "type": "boolean",
          "default": true,
          "description": "Enable serverReady automation (trigger + action). When disabled, provided serverReady payloads are ignored."
        },
        "copilot-debugger.serverReadyDefaultActionType": {
          "type": "string",
          "enum": [
            "httpRequest",
            "shellCommand",
            "vscodeCommand"
          ],
          "default": "httpRequest",
          "description": "Preferred serverReady action type surfaced in samples and quick insert command."
        },
        "copilot-debugger.maxBuildErrors": {
          "type": "integer",
          "default": 5,
          "description": "Maximum number of build diagnostics (from problem matchers) to include in error messages when debug session fails to start.",
          "scope": "resource"
        },
        "copilot-debugger.maxOutputLines": {
          "type": "integer",
          "default": 50,
          "description": "Maximum number of output lines (stderr/stdout) to buffer per debug session for runtime error reporting.",
          "scope": "resource"
        },
        "copilot-debugger.maxOutputChars": {
          "type": "integer",
          "default": 8192,
          "description": "Maximum number of characters returned by Copilot debugger tools (tool output is truncated with a suffix when exceeded).",
          "scope": "resource"
        },
        "copilot-debugger.consoleLogLevel": {
          "type": "string",
          "enum": [
            "trace",
            "debug",
            "info",
            "warn",
            "error",
            "off"
          ],
          "default": "info",
          "description": "Controls how verbosely logs are mirrored to the developer console (Output panel always receives every log; this only gates console.* mirroring). Changes take effect immediately without reloading.",
          "scope": "window"
        },
        "copilot-debugger.enableTraceLogging": {
          "type": "boolean",
          "default": false,
          "description": "Emit verbose Debug Adapter Protocol trace logs to the output channel for troubleshooting.",
          "scope": "window"
        }
      }
    },
    "languageModelTools": [
      {
        "name": "startDebugSessionWithBreakpoints",
        "displayName": "Start Debugger",
        "toolReferenceName": "startDebugSessionWithBreakpoints",
        "canBeReferencedInPrompt": true,
        "userDescription": "Start a debug session, set breakpoints, and wait until a breakpoint is hit. Supports onHit behaviors: break (pause), captureAndContinue (collect variables then auto-resume), captureAndStopDebugging (terminate after hit). Default mode is singleShot: the tool terminates the session before returning so the model cannot accidentally run external curl/browser probes against a paused debuggee. If you need an interactive paused workflow, set mode=inspect.",
        "modelDescription": "Start a debug session using the configured default launch configuration or an explicitly provided configurationName. Auto-selects sole launch config when none specified and no default setting is present. Defaults to 'singleShot' mode (safest), which runs the session, hits a breakpoint, collects data, and terminates automatically. Use 'inspect' mode to pause at a breakpoint for interactive debugging (must provide inspectJustification); while paused, use debugger tools (evaluateExpression) instead of external requests (curl) which may block. Supports 'serverReady' to automatically wait for app startup and trigger a request to hit your breakpoints. Breakpoints support path, code snippet, onHit behavior (break, captureAndContinue, captureAndStopDebugging), variableFilter, condition, and hitCount.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "workspaceFolder": {
              "type": "string",
              "description": "Absolute path of an OPEN workspace folder (required)."
            },
            "configurationName": {
              "type": "string",
              "description": "Name of launch configuration to start. If omitted uses copilot-debugger.defaultLaunchConfiguration or auto-selects sole configuration if exactly one exists."
            },
            "mode": {
              "type": "string",
              "enum": [
                "singleShot",
                "inspect"
              ],
              "description": "Tool mode. singleShot (default): terminate the session before returning. inspect: allow returning while paused for iterative inspection/resume workflows (requires inspectJustification)."
            },
            "inspectJustification": {
              "type": "string",
              "description": "Required when mode is 'inspect'. Explanation of why interactive inspection is needed instead of singleShot."
            },
            "breakpointConfig": {
              "type": "object",
              "properties": {
                "breakpoints": {
                  "type": "array",
                  "minItems": 1,
                  "items": {
                    "type": "object",
                    "properties": {
                      "path": {
                        "type": "string",
                        "description": "File path relative to workspace or absolute."
                      },
                      "code": {
                        "type": "string",
                        "description": "Exact code snippet (substring) to break on. The tool will search the file and set breakpoints on every matching line."
                      },
                      "variableFilter": {
                        "type": "array",
                        "items": {
                          "type": "string"
                        },
                        "description": "Required list of exact variable names to include when reporting variables for this breakpoint or for interpolation in captureAndContinue onHit. Use an empty array to opt into auto-capture (up to captureMaxVariables). Ignored for break/captureAndStopDebugging. Case-sensitive."
                      },
                      "onHit": {
                        "type": "string",
                        "enum": [
                          "break",
                          "captureAndContinue",
                          "captureAndStopDebugging"
                        ],
                        "description": "Breakpoint onHit: break pauses and returns; captureAndContinue collects variables & interpolated log messages then resumes; captureAndStopDebugging collects variables then terminates session after hit."
                      },
                      "condition": {
                        "type": "string",
                        "description": "Optional conditional expression (e.g., 'x > 5'). Breakpoint only triggers when condition evaluates to true."
                      },
                      "hitCount": {
                        "type": "integer",
                        "description": "Exact numeric hit count (3 means pause on 3rd hit)."
                      },
                      "logMessage": {
                        "type": "string",
                        "description": "Optional log message for logpoint or capture action. Uses curly braces for variable interpolation (e.g., 'Value is {x}'). If action=capture, interpolated messages are returned as capturedLogMessages."
                      },
                      "reasonCode": {
                        "type": "string",
                        "description": "Internal telemetry-friendly reason/tag (not surfaced in UI)."
                      }
                    },
                    "required": [
                      "path",
                      "code",
                      "onHit",
                      "variableFilter"
                    ]
                  },
                  "description": "Breakpoints to add before starting session."
                }
              }
            },
            "serverReady": {
              "type": "object",
              "description": "Optional server readiness automation (trigger + action). Canonical pattern for driving a request into a breakpoint is action.type=httpRequest (tool-executed with timeout handling). shellCommand is allowed (including curl), but it can block if it performs a request that hits a break breakpoint. NOTE: the most common failure mode is external curl AFTER the tool returned while paused (inspect mode).",
              "properties": {
                "trigger": {
                  "type": "object",
                  "description": "Readiness trigger. Provide either path+line for breakpoint or pattern for output-based readiness. Omit entirely for immediate attach execution.",
                  "properties": {
                    "path": {
                      "type": "string",
                      "description": "Breakpoint file path (relative or absolute)."
                    },
                    "line": {
                      "type": "integer",
                      "description": "1-based line number for breakpoint trigger."
                    },
                    "pattern": {
                      "type": "string",
                      "description": "Regex pattern matched against debug/task output for readiness."
                    }
                  }
                },
                "action": {
                  "type": "object",
                  "description": "Action executed when ready. Flat schema with discriminator 'type'. Blocking behavior: shellCommand runs in a terminal and may block if it performs a request that hits a break breakpoint; httpRequest is executed by the tool with timeout handling and is recommended for triggering breakpoints.",
                  "properties": {
                    "type": {
                      "type": "string",
                      "enum": [
                        "httpRequest",
                        "shellCommand",
                        "vscodeCommand"
                      ],
                      "description": "Action type discriminator. Prefer httpRequest to trigger requests intended to hit breakpoints. shellCommand is allowed (including curl), but may block if it triggers a break breakpoint."
                    },
                    "url": {
                      "type": "string",
                      "description": "Target URL (httpRequest)."
                    },
                    "method": {
                      "type": "string",
                      "description": "HTTP method (default GET)."
                    },
                    "headers": {
                      "type": "object",
                      "additionalProperties": {
                        "type": "string"
                      },
                      "description": "Optional HTTP headers."
                    },
                    "body": {
                      "type": "string",
                      "description": "Optional HTTP request body."
                    },
                    "shellCommand": {
                      "type": "string",
                      "description": "Shell command executed in a new terminal (shellCommand). Allowed to run curl/wget/etc, but may block if it triggers a break breakpoint."
                    },
                    "command": {
                      "type": "string",
                      "description": "VS Code command ID (vscodeCommand)."
                    },
                    "args": {
                      "type": "array",
                      "description": "Optional VS Code command arguments.",
                      "items": {
                        "type": "string"
                      }
                    }
                  },
                  "required": [
                    "type"
                  ]
                }
              },
              "required": [
                "action"
              ]
            }
          },
          "required": [
            "workspaceFolder",
            "breakpointConfig"
          ],
          "examples": [
            {
              "workspaceFolder": "/abs/path/project",
              "configurationName": "Run test.js",
              "mode": "singleShot",
              "breakpointConfig": {
                "breakpoints": [
                  {
                    "path": "src/server.ts",
                    "line": 27,
                    "action": "capture",
                    "logMessage": "port={PORT}",
                    "variableFilter": [
                      "PORT"
                    ]
                  }
                ]
              },
              "serverReady": {
                "trigger": {
                  "pattern": "listening on .*:(\\d+)"
                },
                "action": {
                  "type": "httpRequest",
                  "url": "http://localhost:%PORT%/swagger"
                }
              }
            },
            {
              "workspaceFolder": "/abs/path/project",
              "mode": "inspect",
              "breakpointConfig": {
                "breakpoints": [
                  {
                    "path": "src/index.ts",
                    "code": "console.log('hello')"
                  }
                ]
              },
              "serverReady": {
                "action": {
                  "type": "shellCommand",
                  "shellCommand": "curl -sS http://localhost:3000/health || exit 1"
                }
              }
            }
          ]
        }
      },
      {
        "name": "resumeDebugSession",
        "displayName": "Resume Debug Session",
        "toolReferenceName": "resumeDebugSession",
        "canBeReferencedInPrompt": true,
        "userDescription": "Resume a paused debug session optionally adding new breakpoints. Breakpoints use the same contract as startDebugSessionWithBreakpoints (path + code snippet + onHit).",
        "modelDescription": "Resume execution of the specified debug session. Optionally wait for next stop and set/clear breakpoints before continuing. Each new breakpoint specifies path + code snippet and optional condition/hitCount/logMessage; onHit supports break, captureAndContinue, captureAndStopDebugging.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "sessionId": {
              "type": "string",
              "description": "ID of the debug session to resume."
            },
            "waitForStop": {
              "type": "boolean",
              "description": "If true, wait until the debugger stops again before returning."
            },
            "breakpointConfig": {
              "type": "object",
              "properties": {
                "breakpoints": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "path": {
                        "type": "string"
                      },
                      "code": {
                        "type": "string",
                        "description": "Exact code snippet (substring) to break on. The tool will search the file and set breakpoints on every matching line."
                      },
                      "variableFilter": {
                        "type": "array",
                        "items": {
                          "type": "string"
                        },
                        "description": "Variable names to include in reporting or interpolation for capture action."
                      },
                      "onHit": {
                        "type": "string",
                        "enum": [
                          "break",
                          "captureAndContinue",
                          "captureAndStopDebugging"
                        ],
                        "description": "Breakpoint onHit behavior. Default break."
                      },
                      "condition": {
                        "type": "string",
                        "description": "Optional conditional expression (e.g., 'x > 5')."
                      },
                      "hitCount": {
                        "type": "integer",
                        "description": "Exact numeric hit count (pause on that occurrence)."
                      },
                      "logMessage": {
                        "type": "string",
                        "description": "Optional log message with {var} interpolation. Returned as capturedLogMessages if action=capture."
                      }
                    },
                    "required": [
                      "path",
                      "code",
                      "variableFilter"
                    ]
                  }
                }
              },
              "required": [
                "workspaceFolder",
                "breakpointConfig"
              ]
            }
          },
          "required": [
            "sessionId"
          ]
        }
      },
      {
        "name": "listDebugSessions",
        "displayName": "List Debug Sessions",
        "toolReferenceName": "listDebugSessions",
        "canBeReferencedInPrompt": true,
        "userDescription": "List active debug sessions and their stop-compatible ids.",
        "modelDescription": "List all active debug sessions. The returned 'id' values are guaranteed to be valid inputs to stopDebugSession(sessionId).",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "getVariables",
        "displayName": "Get Variables",
        "toolReferenceName": "getVariables",
        "canBeReferencedInPrompt": true,
        "userDescription": "Get all variables from the current debug session",
        "modelDescription": "Retrieve a list of all variables and their values from the current debug session when stopped at a breakpoint",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "expandVariable",
        "displayName": "Expand Variable",
        "toolReferenceName": "expandVariable",
        "canBeReferencedInPrompt": true,
        "userDescription": "Show detailed contents and immediate children of a specific variable",
        "modelDescription": "Expand a specific variable to show its detailed contents and immediate child properties/elements when stopped at a breakpoint",
        "inputSchema": {
          "type": "object",
          "properties": {
            "variableName": {
              "type": "string",
              "description": "Name of the variable to expand"
            }
          },
          "required": [
            "variableName"
          ]
        }
      },
      {
        "name": "evaluateExpression",
        "displayName": "Evaluate Expression",
        "toolReferenceName": "evaluateExpression",
        "canBeReferencedInPrompt": true,
        "userDescription": "Evaluate an arbitrary expression (like in Debug Console) in the current paused debug context.",
        "modelDescription": "Use the DAP 'evaluate' request to evaluate code in the paused stack frame. Provide frameId implicitly using top frame.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "expression": {
              "type": "string",
              "description": "Expression to evaluate (e.g., variable name or small snippet)."
            },
            "sessionId": {
              "type": "string",
              "description": "Optional debug session id; defaults to active session."
            }
          },
          "required": [
            "expression"
          ]
        }
      },
      {
        "name": "stopDebugSession",
        "displayName": "Stop Debug Session",
        "toolReferenceName": "stopDebugSession",
        "canBeReferencedInPrompt": true,
        "userDescription": "Terminate one or more debug sessions by id (aligns with resumeDebugSession).",
        "modelDescription": "Stop (terminate) all active debug sessions whose id matches the provided sessionId.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "sessionId": {
              "type": "string",
              "description": "Id of the debug session to stop."
            }
          },
          "required": [
            "sessionId"
          ]
        }
      }
    ]
  },
  "scripts": {
    "vscode:prepublish": "npm run package",
    "compile": "tsc -p ./",
    "update": "vscode-ext-gen",
    "watch": "npm-run-all -p watch:*",
    "watch:esbuild": "node esbuild.js --watch",
    "watch:tsc": "tsc --noEmit --watch -p ./",
    "build:dist": "node esbuild.js --production",
    "package": "npm run build:dist",
    "compile-tests": "tsc -p ./",
    "pretest": "npm run lint && npm run compile-tests && npm run build:dist",
    "lint": "eslint",
    "test": "node -e \"try{require('fs').rmSync('./.vscode-test/user-data',{recursive:true,force:true});}catch(e){}\" && npx vscode-test",
    "test:coverage": "npm run compile-tests && npx vscode-test --coverage",
    "release:notes": "tsx .github/scripts/generate-release-notes.ts",
    "deps": "taze"
  },
  "dependencies": {
    "@actions/core": "^1.11.1",
    "@actions/github": "^6.0.0",
    "@anthropic-ai/sdk": "^0.27.3",
    "@reactive-vscode/reactivity": "^0.4.1",
    "@vscode/prompt-tsx": "^0.4.0-alpha.5",
    "markdown-table": "^3.0.4",
    "mocha": "^10.7.3",
    "reactive-vscode": "^0.4.1",
    "strip-ansi": "^7.1.2"
  },
  "optionalDependencies": {
    "@anthropic-ai/claude-agent-sdk": "^0.1.76"
  },
  "devDependencies": {
    "@antfu/eslint-config": "^3.0.0",
    "@esbuild-plugins/node-modules-polyfill": "^0.2.2",
    "@types/mocha": "^10.0.10",
    "@types/node": "20.x",
    "@types/vscode": "^1.102.0",
    "@typescript-eslint/eslint-plugin": "^8.31.1",
    "@typescript-eslint/parser": "^8.31.1",
    "@vscode/debugprotocol": "^1.68.0",
    "@vscode/test-cli": "^0.0.12",
    "@vscode/test-electron": "^2.5.2",
    "esbuild": "^0.27.0",
    "esbuild-register": "^3.6.0",
    "eslint": "^9.25.1",
    "npm-run-all": "^4.1.5",
    "taze": "^19.9.2",
    "ts-node": "^10.9.2",
    "tsx": "^4.21.0",
    "typescript": "^5.8.3",
    "vscode-ext-gen": "^1.4.0"
  },
  "overrides": {
    "glob": "10.5.0"
  }
}
